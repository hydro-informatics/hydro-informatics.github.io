
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Script-Create a Habitat Suitability Map &#8212; Hydro-Informatics</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet" />
  <link href="../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/sphinx-book-theme.acff12b8f9c144ce68a297486a2fa670.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/tabs.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/tabs.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe,.cell"
        const thebe_selector_input = "pre,.cell_input div.highlight"
        const thebe_selector_output = ".output,.cell_output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"Macros": {"N": "\\mathbb{N}", "floor": ["\\lfloor#1\\rfloor", 1], "bmat": ["\\left[\\begin{array}"], "emat": ["\\end{array}\\right]"]}}, "tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <link rel="canonical" href="https://hydro-informatics.github.io/exercises/ex-geco.html" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Principles" href="../numerics/numerical-modeling.html" />
    <link rel="prev" title="Exercises" href="geo-exercises.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
      <img src="../_static/icon.jpg" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Hydro-Informatics</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <div class="bd-toc-item active">
        <p class="caption">
 <span class="caption-text">
  Get Started
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../lectures/classroom.html">
   The Virtual Classroom
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../lectures/lectures.html">
     Lectures and Exercises
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../lectures/take_seat.html">
     The Virtual Classroom
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../get-started/software.html">
   Software Resources
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../get-started/vm.html">
     Virtual Machines and Linux
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../get-started/ide.html">
     Integrated Development Environments (IDEs)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../python-basics/pyinstall.html">
     Install Python
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../get-started/git.html">
     Introduction to git
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../get-started/geo.html">
     Geospatial Software
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../get-started/install-openfoam.html">
     OpenFOAM (Installation)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../get-started/install-telemac.html">
     TELEMAC (Installation)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../get-started/others.html">
     Other Software Resources
    </a>
   </li>
  </ul>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Python Basics
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../python-basics/python.html">
   First Steps
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../jupyter/pybase.html">
     Hello Data Types
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../jupyter/pyerror.html">
     Errors, Logging, and Debugging
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../jupyter/pyloop.html">
     Loops and Conditional Statements
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../python-basics/modularize.html">
   Object Orientation
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../jupyter/pyfun.html">
     Functions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../jupyter/pypckg.html">
     Packages, Modules and Libraries
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../jupyter/classes.html">
     Object Orientation and Classes
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../python-basics/data-handling.html">
   Data and File Handling
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
  <label for="toctree-checkbox-5">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../jupyter/pynum.html">
     Load and Write Basic Data Files
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../jupyter/xml.html">
     Workbooks (xlsx) and JSON
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../jupyter/pyplot.html">
     Plotting
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../jupyter/pystyle.html">
   Code Style and Conventions
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../jupyter/gui.html">
   Graphical User Interfaces (GUIs)
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="python-exercises.html">
   Python Exercises
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
  <label for="toctree-checkbox-6">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="ex-ms.html">
     1d Hydraulics (Manning-Strickler Formula)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="ex-sp.html">
     Reservoir Volume Calculation with a Sequent Peak Algorithm
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="ex-floods.html">
     Calculate flood return periods
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="ex-sediment.html">
     Cross-section Averaged Sediment Transport
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="ex-gui.html">
     Create a Graphical User Interface (GUI)
    </a>
   </li>
  </ul>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Documentation
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../documentation/documentation.html">
   Markdown and Code Documentation
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="docs-exercises.html">
   Exercises
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
  <label for="toctree-checkbox-7">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="ex-git.html">
     Git and markdown
    </a>
   </li>
  </ul>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Geospatial Analysis
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../geopy/geospatial-data.html">
   Geospatial Data
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../geopy/use-qgis.html">
   QGIS tutorial
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../geopy/geo-python.html">
   Geospatial Python
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/>
  <label for="toctree-checkbox-8">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../geopy/geo-pckg.html">
     Geospatial Python - Open Source Packages
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../jupyter/geo-shp.html">
     Shapefile (vector dataset) handling
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../jupyter/geo-raster.html">
     Raster (Gridded) Dataset Handling
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../jupyter/geo-convert.html">
     Raster to Vector Conversion and Vice Versa
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../jupyter/geo-arcpy.html">
     The Commercial arcpy Library
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="geo-exercises.html">
   Exercises
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/>
  <label for="toctree-checkbox-9">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Script-Create a Habitat Suitability Map
    </a>
   </li>
  </ul>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Numerical Modeling
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../numerics/numerical-modeling.html">
   Principles
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../numerics/pre-qgis.html">
   Pre-Processing with QGIS
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../numerics/basement.html">
   BASEMENT
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../numerics/telemac.html">
   TELEMAC
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/>
  <label for="toctree-checkbox-10">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../numerics/telemac2d.html">
     Pre-Processing for TELEMAC models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../numerics/telemac3d.html">
     3d modeling with TELEMAC
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../numerics/telemac-gaia.html">
     Gaia Workflow
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../numerics/openfoam.html">
   OpenFOAM
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../numerics/calibration.html">
   Calibration and Valdiation
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Troubleshoot
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../troubleshoot/dbg-programming.html">
   Programming Tools and IDEs
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" type="checkbox"/>
  <label for="toctree-checkbox-11">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../troubleshoot/dbg-anaconda.html">
     Debugging Anaconda
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../troubleshoot/dbg-python.html">
     Debugging Python Code
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../troubleshoot/dbg-jupyter.html">
     Debugging Jupyter
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../troubleshoot/dbg-numerical-models.html">
   Numerical Models
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" type="checkbox"/>
  <label for="toctree-checkbox-12">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../troubleshoot/dbg-basement.html">
     Debugging BASEMENT
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../troubleshoot/dbg-telemac.html">
     Debugging TELEMAC/SALOME
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../troubleshoot/dbg-os.html">
   Operating Systems (Linux and VMs)
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" type="checkbox"/>
  <label for="toctree-checkbox-13">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../troubleshoot/dbg-linux.html">
     Debugging Debian Linux
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../troubleshoot/dbg-vm.html">
     Debugging Virtual Machines
    </a>
   </li>
  </ul>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Disclaimer and License
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../terms/license.html">
   License
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../terms/disclaimer.html">
   Disclaimer
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Written by <a href="https://sebastian-schwindt.org">Sebastian Schwindt</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/exercises/ex-geco.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/hydro-informatics/hydro-informatics.github.io"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        
        
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#what-is-habitat-suitability">
   What is Habitat Suitability?
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#available-data-and-code-structure">
   Available data and code structure
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#two-dimensional-2d-hydrodynamic-modelling-folder-basement">
     Two-dimensional (2d) hydrodynamic modelling (folder:
     <strong>
      basement
     </strong>
     )
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#habitat-suitability-index-hsi-curves-folder-habitat">
     Habitat Suitability Index HSI curves (folder:
     <strong>
      habitat
     </strong>
     )
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#code">
     Code
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#create-and-combine-hsi-rasters">
   Create and combine HSI rasters
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#complete-magic-methods-of-the-raster-class-raster-py">
     Complete magic methods of the
     <code class="docutils literal notranslate">
      <span class="pre">
       Raster
      </span>
     </code>
     class (
     <code class="docutils literal notranslate">
      <span class="pre">
       raster.py
      </span>
     </code>
     )
    </a>
   </li>
  </ul>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="script-create-a-habitat-suitability-map">
<span id="ex-geco"></span><h1>Script-Create a Habitat Suitability Map<a class="headerlink" href="#script-create-a-habitat-suitability-map" title="Permalink to this headline">¶</a></h1>
<div class="admonition-goals admonition">
<p class="admonition-title">Goals</p>
<p>This exercise guides through the creation of rasters (<code class="docutils literal notranslate"><span class="pre">osgeo.gdal.Dataset</span></code>), the usage of georeferences, raster array calculations, as well as the conversion of a raster to a polygon shapefile and modifications to the shapefile’s <em>Attribute Table</em> to calculate usable (physical) habitat area. For this purpose, a <code class="docutils literal notranslate"><span class="pre">Raster</span></code> class is written, which enables mathematical operations between its instances through the implementation of magic methods. The exercise also shows how <a class="reference external" href="https://flusstools.readthedocs.io">flusstools</a> can be used to leverage complex challenges with just a few lines of code.</p>
</div>
<div class="attention admonition">
<p class="admonition-title">Requirements</p>
<p><em>Python</em> libraries: <a class="reference internal" href="../jupyter/pynum.html#numpy"><span class="std std-ref">NumPy</span></a>, <a class="reference internal" href="../jupyter/pynum.html#pandas"><span class="std std-ref">Pandas</span></a>, <em>gdal</em>, <em>geopandas</em>, <em>alphashape</em>, <em>shapely</em>, and <a class="reference internal" href="../jupyter/xml.html#json"><span class="std std-ref">JSON</span></a>. Understand how <a class="reference internal" href="../jupyter/classes.html#ooc"><span class="std std-ref">Object Orientation and Classes</span></a> work as well as <a class="reference internal" href="../geopy/geo-python.html#sec-geo-python"><span class="std std-ref">Geospatial Python</span></a>.</p>
</div>
<p>Get ready by cloning the exercise repository:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">clone</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">Ecohydraulics</span><span class="o">/</span><span class="n">Exercise</span><span class="o">-</span><span class="n">geco</span><span class="o">.</span><span class="n">git</span>
</pre></div>
</div>
<div class="figure align-default" id="fish">
<img alt="fish Sacramento succer south yuba river" src="https://github.com/Ecohydraulics/media/raw/master/jpg/yuba-fish.jpg" />
<p class="caption"><span class="caption-number">Fig. 18 </span><span class="caption-text">Sacramento suckers in the South Yuba River (source: Sebastian Schwindt 2019).</span><a class="headerlink" href="#fish" title="Permalink to this image">¶</a></p>
</div>
<div class="section" id="what-is-habitat-suitability">
<h2>What is Habitat Suitability?<a class="headerlink" href="#what-is-habitat-suitability" title="Permalink to this headline">¶</a></h2>
<p>Fish and other aquatic species rest, orient, and reproduce in a fluvial environment that represents their physical habitat. Throughout their different life stages, different fish have specific physical habitat preferences which are defined, for instance, as a function of water depth, flow velocity, and grain size of the riverbed. The so-called <em>Habitat Suitability Index <em><span class="math notranslate nohighlight">\(HSI\)</span></em></em> can be calculated for hydraulic (water depth or flow velocity) and morphological (e.g., grain size or cover in the form of large wood) parameters individually to describe the quality of physical habitat for a fish and at a specific life stage. The figure below shows exemplary <span class="math notranslate nohighlight">\(HSI\)</span> curves for the fry, juvenile and adult life stages of rainbow trout as a function of water depth. The <span class="math notranslate nohighlight">\(HSI\)</span> curves look different in every river and should be established individually by an aquatic ecologist.
<a name="hsi-image"></a></p>
<p><img alt="hsi-curves" src="https://github.com/Ecohydraulics/media/raw/master/png/hsi-curves.png" /><br>
<em>Habitat Suitability Index (HSI) curves for the fry, juvenile, and adult life stages of rainbow trout in a cobble-bed river. Take care: HSI curves look different in any river and need to be established by an aquatic ecologist.</em></p>
<p>The <span class="math notranslate nohighlight">\(HSI\)</span> concept also accounts for the so-called cover habitat in the form of the <em>cover HSI</em> (<span class="math notranslate nohighlight">\(HSI_{cov}\)</span>). Cover habitat is the result of local turbulence caused by roughness elements such as wood, boulders, or bridge piers. However, in this exercise, we will only deal with hydraulic habitat characteristics (not cover habitat).</p>
<p><img alt="cover-habitat" src="https://github.com/Ecohydraulics/media/raw/master/jpg/neckar-fish-cover.jpg" /><br>
<em>Adult trout swimming in cover habitat created by a bridge pier in the upper Neckar River.</em></p>
<p>The combination of multiple <span class="math notranslate nohighlight">\(HSI\)</span> values (e.g., water depth-related <span class="math notranslate nohighlight">\(HSI_{h}\)</span>, flow velocity-related <span class="math notranslate nohighlight">\(HSI_{u}\)</span>, grain size-related <span class="math notranslate nohighlight">\(HSI_{d}\)</span>, and/or cover <span class="math notranslate nohighlight">\(HSI_{cov}\)</span>) results in the <strong>combined Habitat Suitability Index</strong> <span class="math notranslate nohighlight">\(cHSI\)</span>. There are various calculation methods for combining different <span class="math notranslate nohighlight">\(HSI_{par}\)</span> values into one <span class="math notranslate nohighlight">\(cHSI\)</span> value, where the geometric mean and the product are the most widely used deterministic combination methods: <a name="combine-methods"></a></p>
<ul class="simple">
<li><p>Geometric mean:  <span class="math notranslate nohighlight">\(cHSI = (\product_{par} HSI_{par})^{1/n}\)</span>
<br>For example, the combination of the water depth-related <span class="math notranslate nohighlight">\(HSI_{h}\)</span> and flow velocity-related <span class="math notranslate nohighlight">\(HSI_{u}\)</span> with the geometric mean method is: <span class="math notranslate nohighlight">\(cHSI = (HSI_{h} \cdot HSI_{u})^{1/2}\)</span></p></li>
<li><p>Product:  <span class="math notranslate nohighlight">\(cHSI = \product_{par} HSI_{par}\)</span>
<br>For example, the combination of the water depth-related <span class="math notranslate nohighlight">\(HSI_{h}\)</span> and flow velocity-related <span class="math notranslate nohighlight">\(HSI_{u}\)</span> with the product method is: <span class="math notranslate nohighlight">\(cHSI = (HSI_{h} \cdot HSI_{u})\)</span></p></li>
</ul>
<p>Therefore, if the pixel-based <span class="math notranslate nohighlight">\(HSI\)</span> values for water depth and flow velocity are known from a two-dimensional (2d) hydrodynamic model, then for each pixel the <span class="math notranslate nohighlight">\(cHSI\)</span> value can be calculated either as the product or geometric mean of the single-parameter <span class="math notranslate nohighlight">\(HSI_{par}\)</span> rasters.</p>
<p>This habitat assessment concept was introduced by <a class="reference external" href="https://pubs.er.usgs.gov/publication/70121265">Bovee (1986)</a> and <a class="reference external" href="https://apps.dtic.mil/sti/pdfs/ADA322762.pdf">Stalnaker (1995)</a>. However, these authors built their usable (physical) habitat assessment based on one-dimensional (1d) numerical models that were commonly used in the last millennium. Today, 2d numerical models are the state-of-the-art to determine physical habitat geospatially explicit based on pixel-based <span class="math notranslate nohighlight">\(cHSI\)</span> values. There are two different options for calculating the usable habitat area (<span class="math notranslate nohighlight">\(UHA\)</span>) based on pixel-based <span class="math notranslate nohighlight">\(cHSI\)</span> values (and even more options can be found in the scientific literature). <a name="uha-methods"></a></p>
<ol class="simple">
<li><p>Use a threshold value above which a pixel is classified as a usable habitat.</p>
<ul class="simple">
<li><p>Typical values for the threshold value <span class="math notranslate nohighlight">\(cHSI_{crit}\)</span> are between 0.4 (tolerant) and 0.75 (strict).</p></li>
<li><p>The usable habitat area <span class="math notranslate nohighlight">\(UHA\)</span> results from the pixel size <span class="math notranslate nohighlight">\(px_{a}\)</span> (e.g., in m<span class="math notranslate nohighlight">\(^2\)</span>) multiplied by the number of pixels (<span class="math notranslate nohighlight">\(px\)</span>) where <span class="math notranslate nohighlight">\(cHSI &gt; cHSI_{crit}\)</span>:
<br><span class="math notranslate nohighlight">\(UHA = px_{a} \cdot \sum px_{i}(cHSI_{px_{i}} &gt; cHSI_{crit})\)</span></p></li>
</ul>
</li>
<li><p>Multiply the pixel <span class="math notranslate nohighlight">\(cHSI\)</span> value with the pixel size.</p>
<ul class="simple">
<li><p>The pixel area is weighted by its habitat quality expressed by the <span class="math notranslate nohighlight">\(cHSI\)</span> value:
&lt;br<span class="math notranslate nohighlight">\(UHA = px_{a} \cdot \sum cHSI_{px_{i}}\)</span></p></li>
<li><p>Caution: Some authors (e.g., <a class="reference external" href="https://onlinelibrary.wiley.com/doi/full/10.1002/eco.1961">Yao et al. 2018</a>, <a class="reference external" href="https://doi.org/10.1007/s12205-012-0002-5">Tuhtan et al.</a> incorrectly refer to this weighting as Weighted Usable Area (<em>WUA</em>), which conflicts with the original definition of <em>WUA</em> (<a class="reference external" href="https://pubs.er.usgs.gov/publication/70121265">Bovee 1986</a>).</p></li>
</ul>
</li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The threshold method is preferable over the weighting method because the <span class="math notranslate nohighlight">\(HSI\)</span>  has the unit of <em>Index</em> and is therefore not dimensionless. As a result, unrealistic units of <em>Index</em> areas (e.g., <em>Index</em>-m<span class="math notranslate nohighlight">\(^2\)</span>) are created in the weighting method, which is also introducing non-measurable uncertainty.</p>
</div>
<p>An alternative to the deterministic calculation of the <span class="math notranslate nohighlight">\(HSI\)</span> and <span class="math notranslate nohighlight">\(cHSI\)</span> values of a pixel is a fuzzy logics approach (<a class="reference external" href="https://onlinelibrary.wiley.com/doi/pdf/10.1002/9781118526576">Noack et al. 2013</a>). In the fuzzy logic approach, pixels are classified, for instance, as <em>low</em>, <em>medium</em>, or <em>high</em> habitat quality as a function of the associated water depth or flow velocity using categorical (<em>low</em>, <em>medium</em>, or <em>high</em>), expert assessment-based <span class="math notranslate nohighlight">\(HSI\)</span> curves. The <span class="math notranslate nohighlight">\(cHSI\)</span> value results from the center of gravity of superimposed membership functions of considered parameters (e.g., water depth and flow velocity).</p>
<p>Sustainable river management involves the challenge of designing aquatic habitat for target fish species at different life stages. The concept of usable physical habitat area represents a powerful tool to leverage the assessment of the ecological integrity of river management and engineering measures. For example, by calculating the usable habitat area before and after the implementation of measures, valuable conclusions can be drawn about the ecological integrity of restoration efforts.</p>
<p>This exercise demonstrates the use of 2d hydrodynamic modeling results to algorithmically evaluate usable habitat area based on the calculation of geospatially explicit <span class="math notranslate nohighlight">\(cHSI\)</span> values.</p>
</div>
<div class="section" id="available-data-and-code-structure">
<h2>Available data and code structure<a class="headerlink" href="#available-data-and-code-structure" title="Permalink to this headline">¶</a></h2>
<p>The following flow chart illustrates the provided code and data. Functions, methods, and files to be created in this exercise are highlighted in bold, italic, <em>YELLOW</em> font.</p>
<p><a name="uml"></a>
<img alt="code-structure" src="https://github.com/Ecohydraulics/Exercise-geco/raw/master/graphs/geo_eco_uml.png" /><br></p>
<p>The provided <em>QGIS</em> project file <code class="docutils literal notranslate"><span class="pre">visualize_with_QGIS.qgz</span></code> helps to verify input raster datasets and results.</p>
<div class="section" id="two-dimensional-2d-hydrodynamic-modelling-folder-basement">
<span id="dm"></span><h3>Two-dimensional (2d) hydrodynamic modelling (folder: <strong>basement</strong>)<a class="headerlink" href="#two-dimensional-2d-hydrodynamic-modelling-folder-basement" title="Permalink to this headline">¶</a></h3>
<p>This exercise uses (hydraulic) flow velocity and water depth rasters (<em>GeoTIFF</em>s) produced with the <a class="reference external" href="https://basement.ethz.ch/"><em>ETH Zurich</em>’s <em>BASEMENT</em></a> software. Read more about hydrodynamic modeling with <em>BASEMENT</em> in the <span class="xref std std-ref">basement</span> chapter. The hydraulic rasters were produced with the <em>BASEMENT</em> developer’s <a class="reference external" href="http://people.ee.ethz.ch/~basement/baseweb/download/tutorials/Flaz_2d_v3.zip">example data from the <em>Flaz River</em></a> in Switzerland (<a class="reference external" href="https://basement.ethz.ch/download/tutorials/tutorials3.html">read more on their website</a>).
The water depth <code class="docutils literal notranslate"><span class="pre">water_depth.tif</span></code> and flow velocity <code class="docutils literal notranslate"><span class="pre">flow_velocity.tif</span></code> rasters are provided for this exercise in the folder <code class="docutils literal notranslate"><span class="pre">/basement/</span></code>.</p>
</div>
<div class="section" id="habitat-suitability-index-hsi-curves-folder-habitat">
<span id="hsi-curves"></span><h3>Habitat Suitability Index HSI curves (folder: <strong>habitat</strong>)<a class="headerlink" href="#habitat-suitability-index-hsi-curves-folder-habitat" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">/habitat/</span></code> folder in the exercise repository contains <span class="math notranslate nohighlight">\(HSI\)</span> curves in the form of an <em>xlsx</em> workbook (<code class="docutils literal notranslate"><span class="pre">trout.xlsx</span></code>) and in the form of a <a class="reference internal" href="../jupyter/xml.html#json"><span class="std std-ref">JSON</span></a> file (<code class="docutils literal notranslate"><span class="pre">trout.json</span></code>). Both files contain the same data for rainbow trout of a hypothetical cobble-bed river and this exercise only uses the <em>JSON</em> file (the workbook serves for visual verification only).</p>
</div>
<div class="section" id="code">
<h3>Code<a class="headerlink" href="#code" title="Permalink to this headline">¶</a></h3>
<p><em><strong>GEO_UTILS (folder: geo_utils)</strong></em><br>
A couple of <code class="docutils literal notranslate"><span class="pre">gdal</span></code>-based functions for processing rasters and shapefiles were introduced in the lecture. This exercise re-uses some of these functions, which are available in the geo-processing code repository specifically for this ebook. The repository contains a functional block from <a class="reference external" href="https://flusstools.readthedocs.io">flusstools</a>.geotools (in the <code class="docutils literal notranslate"><span class="pre">geo_utils</span></code> folder) that enables to better understand and modify the behavior of <a class="reference external" href="https://flusstools.readthedocs.io">flusstools</a>.
Even though already provided in this exercise, make sure that the <em>geo_utils</em> repository is well implemented in the exercise directory (i.e., <em>geo_utils</em> scripts are stored in a folder tree like this: <code class="docutils literal notranslate"><span class="pre">Exercise-geco\geo_utils\</span></code>). The <code class="docutils literal notranslate"><span class="pre">\geo_utils\</span></code> folder corresponds to the <code class="docutils literal notranslate"><span class="pre">geo-utils\geo_utils\</span></code> directory when you clone the repository.</p>
<div class="admonition attention">
<p class="admonition-title">Attention</p>
<p>Make sure that in the <code class="docutils literal notranslate"><span class="pre">\geo_utils\geoconfig.py</span></code> file, the <code class="docutils literal notranslate"><span class="pre">nan_value</span></code> is defined as 0.0 (<code class="docutils literal notranslate"><span class="pre">nan_value</span> <span class="pre">=</span> <span class="pre">0.0</span></code>).</p>
</div>
<p><em><strong><a class="reference external" href="http://CONFIG.PY">CONFIG.PY</a></strong></em><br>
The code in this exercise uses a <code class="docutils literal notranslate"><span class="pre">config.py</span></code> file where all necessary libraries and global variables are loaded centrally.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># This is config.py</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">string</span>
<span class="kn">import</span> <span class="nn">json</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">import</span> <span class="nn">geo_utils</span> <span class="k">as</span> <span class="nn">geo</span>

<span class="n">cache_folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">__cache__</span><span class="se">\\</span><span class="s2">&quot;</span>
<span class="n">par_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;velocity&quot;</span><span class="p">:</span> <span class="s2">&quot;u&quot;</span><span class="p">,</span>
            <span class="s2">&quot;depth&quot;</span><span class="p">:</span> <span class="s2">&quot;h&quot;</span><span class="p">,</span>
            <span class="s2">&quot;grain_size&quot;</span><span class="p">:</span> <span class="s2">&quot;d&quot;</span><span class="p">}</span>
<span class="n">nan_value</span> <span class="o">=</span> <span class="mf">0.0</span>
</pre></div>
</div>
<p><em><strong><a class="reference external" href="http://FUN.PY">FUN.PY</a> (FUNCTIONS)</strong></em><br>
At this point in the course, it is assumed that students are familiar with object orientation and especially with writing functions. Therefore, many basic functions for this exercise are already provided with the script <code class="docutils literal notranslate"><span class="pre">fun.py</span></code> (alphabetically ordered list):
<a name="funs"></a></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cache</span></code> is a wrapper for parent functions to enforce that intermediate geospatial datasets (e.g., the intermediate product of a sum of rasters) are stored in a temporary <em>cache</em> folder that is deleted after the script ran.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">check_cache</span></code> verifies if the cache folder defined in <code class="docutils literal notranslate"><span class="pre">config.py</span></code> already exists. The function is automatically called by the <code class="docutils literal notranslate"><span class="pre">cache</span></code> wrapper.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">create_random_string(length)</span></code> generates unique file names for temporary (cached) datasets, where <code class="docutils literal notranslate"><span class="pre">length</span></code> is an <em>integer</em> value that determines the number of characters of the random string to be created.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">interpolate_from_list(x_values,</span> <span class="pre">y_values,</span> <span class="pre">xi_values)</span></code> linearly interpolates *y_{i}<span class="math notranslate nohighlight">\( values from two sorted lists containing paired *x* and *y* values for a {ref}`list` of given *x_{i}\)</span> values (returns a <code class="docutils literal notranslate"><span class="pre">numpy.array</span></code> of the same length as <code class="docutils literal notranslate"><span class="pre">xi_values</span></code>). If one of the *x_{i}$ values is beyond the value range of <code class="docutils literal notranslate"><span class="pre">x_values</span></code>, the function appends the <code class="docutils literal notranslate"><span class="pre">nan_value</span></code> defined in <code class="docutils literal notranslate"><span class="pre">config.py</span></code> to the results array.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">interpolate_y(x1,</span> <span class="pre">x2,</span> <span class="pre">y1,</span> <span class="pre">y2,</span> <span class="pre">xi)</span></code> is called by the <code class="docutils literal notranslate"><span class="pre">interpolate_from_list</span></code> function for paired lower and upper <code class="docutils literal notranslate"><span class="pre">x1</span></code>-<code class="docutils literal notranslate"><span class="pre">y1</span></code> and <code class="docutils literal notranslate"><span class="pre">x2</span></code>-<code class="docutils literal notranslate"><span class="pre">y2</span></code> <em>float</em>s of the <code class="docutils literal notranslate"><span class="pre">x_values</span></code> and <code class="docutils literal notranslate"><span class="pre">y_values</span></code> <a class="reference internal" href="../jupyter/pybase.html#list"><span class="std std-ref">List</span></a>s (returns a <em>float</em> number corresponding to the linearly interpolated <code class="docutils literal notranslate"><span class="pre">yi</span></code> value of the <code class="docutils literal notranslate"><span class="pre">xi</span></code>-<code class="docutils literal notranslate"><span class="pre">yi</span></code> pair between <code class="docutils literal notranslate"><span class="pre">x1</span></code>-<code class="docutils literal notranslate"><span class="pre">y1</span></code> and <code class="docutils literal notranslate"><span class="pre">x2</span></code>-<code class="docutils literal notranslate"><span class="pre">y2</span></code>). If <code class="docutils literal notranslate"><span class="pre">xi</span></code> is not numeric, or if the interpolation results in a <code class="docutils literal notranslate"><span class="pre">ZeroDivisionError</span></code>, the function returns the <code class="docutils literal notranslate"><span class="pre">nan_value</span></code> defined in <code class="docutils literal notranslate"><span class="pre">config.py</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">log_actions(fun)</span></code> wraps a function (<code class="docutils literal notranslate"><span class="pre">fun</span></code>), where actions should be written to a logfile. Logging is started with the <code class="docutils literal notranslate"><span class="pre">start_logging</span></code> function (see below) and logging is stopped with <code class="docutils literal notranslate"><span class="pre">logging.shutdown()</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">read_json</span></code> opens a <em>JSON</em> file and returns it as <em>Python</em> object. In this exercise, this function will be used to open the <code class="docutils literal notranslate"><span class="pre">/habitat/trout.json</span></code> file. The <span class="math notranslate nohighlight">\(HSI\)</span> values can then be assessed from the <em>JSON</em> object, for example:</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">trout</span> <span class="o">=</span> <span class="n">read_json</span><span class="p">(</span><span class="s2">&quot;PATH/&quot;</span> <span class="o">+</span> <span class="s2">&quot;trout.json&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">trout</span><span class="p">[</span><span class="s2">&quot;velocity&quot;</span><span class="p">][</span><span class="s2">&quot;spawning&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;u&quot;</span><span class="p">])</span>

<span class="o">&gt;&gt;&gt;</span> <span class="mf">0.0198</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">remove_directory(directory)</span></code> removes a <code class="docutils literal notranslate"><span class="pre">directory</span></code> (<em>string</em> argument). Be careful, this function aggressively removes the <code class="docutils literal notranslate"><span class="pre">directory</span></code> and all its contents with little chance of data recovery.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">start_logging()</span></code> starts logging to a logfile (<code class="docutils literal notranslate"><span class="pre">logfile.log</span></code>) and the <em>Python</em> console at the <code class="docutils literal notranslate"><span class="pre">logging.DEBUG</span></code> level.</p></li>
</ul>
<p><em><strong><a class="reference external" href="http://RASTER.PY">RASTER.PY</a> / RASTER_HSI.PY</strong></em><br>
The parent <code class="docutils literal notranslate"><span class="pre">Raster</span></code> class is stored in the <code class="docutils literal notranslate"><span class="pre">raster.py</span></code> script, where magic methods, a <em>pseudo</em> private <code class="docutils literal notranslate"><span class="pre">_make_raster</span></code>, and a <code class="docutils literal notranslate"><span class="pre">save</span></code> method will be created in this exercise.
The <code class="docutils literal notranslate"><span class="pre">HSIRaster</span></code> class in the <code class="docutils literal notranslate"><span class="pre">raster_hsi.py</span></code> script is a child of the <code class="docutils literal notranslate"><span class="pre">Raster</span></code> class. In this exercise, we will only look at how this child class is structured and what it produces (i.e., no modifications are necessary).</p>
<p><em><strong>CREATE_HSI_RASTERS.PY and CALCULATE_HABITAT_AREA.PY</strong></em><br>
The two scripts <code class="docutils literal notranslate"><span class="pre">reate_hsi_rasters.py</span></code> and <code class="docutils literal notranslate"><span class="pre">calculate_habitat_area.py</span></code> represent the focal point of this exercise and make use of the provided data and <em>Python</em> scripts. Therefore, only the basic framework functions and imports are pre-existing in these two template scripts.</p>
</div>
</div>
<div class="section" id="create-and-combine-hsi-rasters">
<span id="py-raster-calculator"></span><h2>Create and combine HSI rasters<a class="headerlink" href="#create-and-combine-hsi-rasters" title="Permalink to this headline">¶</a></h2>
<div class="section" id="complete-magic-methods-of-the-raster-class-raster-py">
<span id="raster-class"></span><h3>Complete magic methods of the <code class="docutils literal notranslate"><span class="pre">Raster</span></code> class (<code class="docutils literal notranslate"><span class="pre">raster.py</span></code>)<a class="headerlink" href="#complete-magic-methods-of-the-raster-class-raster-py" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">raster.py</span></code> script imports the functions and libraries loaded in the <code class="docutils literal notranslate"><span class="pre">fun.py</span></code> script, and therefore, also the <code class="docutils literal notranslate"><span class="pre">config.py</span></code> script. For this reason, the <a class="reference internal" href="../jupyter/pynum.html#numpy"><span class="std std-ref">NumPy</span></a> and <a class="reference internal" href="../jupyter/pynum.html#pandas"><span class="std std-ref">Pandas</span></a> libraries are already available (<code class="docutils literal notranslate"><span class="pre">as</span></code> <code class="docutils literal notranslate"><span class="pre">np</span></code> and <code class="docutils literal notranslate"><span class="pre">pd</span></code>, respectively), and the <em>geo_utils</em> package is already imported as <code class="docutils literal notranslate"><span class="pre">geo</span></code> (<code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">geo_utils</span> <span class="pre">as</span> <span class="pre">geo</span></code> in <code class="docutils literal notranslate"><span class="pre">config.py</span></code>).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Raster</span></code> class will load any <em>GeoTIFF</em> file name as a geo-referenced array object that can be used with mathematical operators. First, we will complement the <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method by a <code class="docutils literal notranslate"><span class="pre">Raster.name</span></code> (extract from the <code class="docutils literal notranslate"><span class="pre">file_name</span></code> argument), as well as georeferences and array datasets:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="c1"># __init__(...) of Raster class in raster.py</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">file_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>If the provided <code class="docutils literal notranslate"><span class="pre">file_name</span></code> does not exist, the <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method creates a new raster with the <code class="docutils literal notranslate"><span class="pre">file_name</span></code> (this behaviour is already implemented in the <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">not</span> <span class="pre">os.path.exists(file_name)</span></code> statement.
Next, load the <code class="docutils literal notranslate"><span class="pre">osgeo.gdal.dataset</span></code>, the <code class="docutils literal notranslate"><span class="pre">np.array</span></code>, and the <code class="docutils literal notranslate"><span class="pre">geo_transformation</span></code> of the raster. For this purpose, use the <a class="reference external" href="geopy/geo-raster.html#createarray"><em>raster2array</em> function</a> from the lecture, which is also implemented in <em>geo_utils</em> (<code class="docutils literal notranslate"><span class="pre">geo</span></code>):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="c1"># __init__(...) of Raster class in raster.py</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">geo_transformation</span> <span class="o">=</span> <span class="n">geo</span><span class="o">.</span><span class="n">raster2array</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">band_number</span><span class="o">=</span><span class="n">band</span><span class="p">)</span>
</pre></div>
</div>
<p>To identify the <a class="reference external" href="geopy/geospatial-data.html#prj"><em>EPSG</em> number (Authority code)</a> of a raster, retrieve the spatial reference system (<em>SRS</em>) of the raster. Also for this purpose we have already developed a function in the lecture with the <a class="reference external" href="geopy/geo-raster.html#reproject"><em>get_srs</em> function</a>. Load the <em>SRS</em> and the <em>EPSG</em> number using the <em>get_srs</em> function with the following two lines of code in the <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="c1"># __init__(...) of Raster class in raster.py</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">srs</span> <span class="o">=</span> <span class="n">geo</span><span class="o">.</span><span class="n">get_srs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">epsg</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">srs</span><span class="o">.</span><span class="n">GetAuthorityCode</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<p>That is it. The <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method of the <code class="docutils literal notranslate"><span class="pre">Raster</span></code> class is complete.</p>
<hr class="docutils" />
<p>To enable mathematical operations between multiple instances of the <code class="docutils literal notranslate"><span class="pre">Raster</span></code> class, implement <a class="reference internal" href="../jupyter/classes.html#magic"><span class="std std-ref">Overloading and Magic Methods</span></a> that tell the class what to do when two <code class="docutils literal notranslate"><span class="pre">Raster</span></code> instances are for example added (<code class="docutils literal notranslate"><span class="pre">+</span></code> sign), multiplied (<code class="docutils literal notranslate"><span class="pre">*</span></code> sign), or subtracted (<code class="docutils literal notranslate"><span class="pre">-</span></code> sign). For instance, implementing the magic methods <code class="docutils literal notranslate"><span class="pre">__truediv__</span></code> (for using the <code class="docutils literal notranslate"><span class="pre">/</span></code> operator), <code class="docutils literal notranslate"><span class="pre">__mul__</span></code> (for using the <code class="docutils literal notranslate"><span class="pre">*</span></code> operator), and <code class="docutils literal notranslate"><span class="pre">__pow__</span></code> (for using the <code class="docutils literal notranslate"><span class="pre">**</span></code> operator) will enable the usage of <code class="docutils literal notranslate"><span class="pre">Raster</span></code> instances like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># example for Raster instances, when operators are defined through magic methods</span>

<span class="c1"># load GeoTIFF rasters from file directory</span>
<span class="n">velocity</span> <span class="o">=</span> <span class="n">Raster</span><span class="p">(</span><span class="s2">&quot;/usr/geodata/u.tif&quot;</span><span class="p">)</span>
<span class="n">depth</span> <span class="o">=</span> <span class="n">Raster</span><span class="p">(</span><span class="s2">&quot;/usr/geodata/h.tif&quot;</span><span class="p">)</span>

<span class="c1"># calculate the Froude number using operators defined with magic methods</span>
<span class="n">Froude</span> <span class="o">=</span> <span class="n">velocity</span> <span class="o">/</span> <span class="p">(</span><span class="n">depth</span> <span class="o">*</span> <span class="mf">9.81</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>

<span class="c1"># save the new raster</span>
<span class="n">Froude</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;/usr/geodata/froude.tif&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Raster</span></code> class template already contains one exemplary magic method to enable division (<code class="docutils literal notranslate"><span class="pre">__truediv__</span></code>):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="c1"># Raster class in raster.py</span>
    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constant_or_raster</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">constant_or_raster</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">/=</span> <span class="n">constant_or_raster</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_raster</span><span class="p">(</span><span class="s2">&quot;div&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Let us take a close look at what the <code class="docutils literal notranslate"><span class="pre">__truediv__</span></code> method does:</p>
<ul class="simple">
<li><p>The input argument <code class="docutils literal notranslate"><span class="pre">constant_or_raster</span></code> can be another <code class="docutils literal notranslate"><span class="pre">Raster</span></code> instance that has an <code class="docutils literal notranslate"><span class="pre">array</span></code> attribute or a numeric constant (e.g., 9.81).</p></li>
<li><p>The method tries to invoke the array attribute of <code class="docutils literal notranslate"><span class="pre">constant_or_raster</span></code>.</p>
<ul>
<li><p>If <code class="docutils literal notranslate"><span class="pre">constant_or_raster</span></code> is a raster object, then invoking <code class="docutils literal notranslate"><span class="pre">contant_or_raster.array</span></code> is successful. In this case <code class="docutils literal notranslate"><span class="pre">self.array</span></code> is overwritten with the element-wise division of the array by <code class="docutils literal notranslate"><span class="pre">contant_or_raster.array</span></code>. The element-wise division builds on <a class="reference internal" href="../jupyter/pynum.html#numpy"><span class="std std-ref">NumPy</span></a>s built-in function <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.divide.html"><em>np.divide</em></a>, which is a computationally efficient wrapper of C/C++ code (much faster than a <em>Python</em> loop over array elements).</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">constant_or_raster</span></code> is a numeric value, then invoking <code class="docutils literal notranslate"><span class="pre">contant_or_raster.array</span></code> results in an <code class="docutils literal notranslate"><span class="pre">AttributeError</span></code> and the <code class="docutils literal notranslate"><span class="pre">__truediv__</span></code> method falls in the <code class="docutils literal notranslate"><span class="pre">except</span> <span class="pre">AttributeError</span></code> statement, where <code class="docutils literal notranslate"><span class="pre">self.array</span></code> is simply divided by <code class="docutils literal notranslate"><span class="pre">constant_or_raster</span></code>.</p></li>
</ul>
</li>
<li><p>The method returns the result of the pseudo private method <code class="docutils literal notranslate"><span class="pre">self._make_raster(&quot;div&quot;)</span></code> ([recall <em>PEP 8</em> <a class="reference internal" href="../jupyter/pystyle.html#chpt-style"><span class="std std-ref">Code Style and Conventions</span></a>, which corresponds to a new <code class="docutils literal notranslate"><span class="pre">Raster</span></code> instance of the actual <code class="docutils literal notranslate"><span class="pre">Raster</span></code> instance divided by <code class="docutils literal notranslate"><span class="pre">constant_or_raster</span></code>. The new <code class="docutils literal notranslate"><span class="pre">Raster</span></code> instance is a temporary <em>GeoTIFF</em>  file in the <em>cache</em> folder (<a class="reference external" href="#funs">recall the cache function</a>). This is how the pseudo-private method <code class="docutils literal notranslate"><span class="pre">_make_raster(self,</span> <span class="pre">file_marker)</span></code> looks like:<a name="make-raster"></a></p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="nf">_make_raster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_marker</span><span class="p">):</span>
        <span class="n">f_ending</span> <span class="o">=</span> <span class="s2">&quot;__</span><span class="si">{0}{1}</span><span class="s2">__.tif&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">file_marker</span><span class="p">,</span> <span class="n">create_random_string</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">geo</span><span class="o">.</span><span class="n">create_raster</span><span class="p">(</span><span class="n">cache_folder</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="n">f_ending</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">epsg</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">epsg</span><span class="p">,</span>
                          <span class="n">nan_val</span><span class="o">=</span><span class="n">nan_value</span><span class="p">,</span>
                          <span class="n">geo_info</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_transformation</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Raster</span><span class="p">(</span><span class="n">cache_folder</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="n">f_ending</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">file_marker</span></code> is a <em>string</em> variable added to the <em>GeoTIFF</em> file name along with a random, four characters-long <em>string</em> (<a class="reference external" href="#funs">recall the <code class="docutils literal notranslate"><span class="pre">create_random_string</span></code> function</a>). <code class="docutils literal notranslate"><span class="pre">file_marker</span></code> is unique for every implemented operator. For the <code class="docutils literal notranslate"><span class="pre">__truediv__</span></code> method use <code class="docutils literal notranslate"><span class="pre">file_marker=&quot;div&quot;</span></code>. Thus, the temporary <em>GeoTIFF</em> file name is defined as <code class="docutils literal notranslate"><span class="pre">cache_folder</span> <span class="pre">+</span> <span class="pre">self.name</span> <span class="pre">+</span> <span class="pre">f_ending</span></code> (e.g. <code class="docutils literal notranslate"><span class="pre">&quot;C:\Excercise-geco\__cache__\velocity__divhjev__.tif&quot;</span></code>).</p></li>
<li><p>From <code class="docutils literal notranslate"><span class="pre">geo_utils</span></code>, the <a class="reference external" href="geopy/geo-raster.html#create"><code class="docutils literal notranslate"><span class="pre">create_raster</span></code></a> function is used to actually write the temporary <em>GeoTIFF</em> to the <code class="docutils literal notranslate"><span class="pre">__cache__</span></code> folder using the original raster’s spatial reference system.</p></li>
<li><p>The method <code class="docutils literal notranslate"><span class="pre">return</span></code>s a new <code class="docutils literal notranslate"><span class="pre">Raster</span></code> instance of the temporary, cached <em>GeoTIFF</em> file.</p></li>
</ul>
<p>````{admonition} Digression: If you think the <code class="docutils literal notranslate"><span class="pre">_make_raster</span></code> method is confusing …
:class: tip, dropdown</p>
<p>Then you have a point. The above-described approach implements the <code class="docutils literal notranslate"><span class="pre">_make_raster</span></code> method to reuse the temporary <em>GeoTIFF</em>s later with both constants (<em>float</em>) and arrays, but there is a more elegant way to return a new <code class="docutils literal notranslate"><span class="pre">Raster</span></code> instance. However, returning a new instance of the same class requires that the input argument must be an instance of the class itself (i.e., <code class="docutils literal notranslate"><span class="pre">Raster</span></code>) and not a numeric variable. The alternative solution for returning a <code class="docutils literal notranslate"><span class="pre">Raster</span></code> instance starts with a different implementation of the magic method (e.g., <code class="docutils literal notranslate"><span class="pre">__truediv__</span></code>) and requires to import <em>Python4</em>-style <code class="docutils literal notranslate"><span class="pre">annotations</span></code>. Therefore, the first line of the script must include (only works with <em>Python 3.7</em> and higher) the following import:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>
</pre></div>
</div>
<p>Then we can rewrite the <code class="docutils literal notranslate"><span class="pre">__truediv__</span></code> method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Raster</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Raster</span><span class="p">:</span>
        <span class="n">f_ending</span> <span class="o">=</span> <span class="s2">&quot;__div</span><span class="si">%s</span><span class="s2">__.tif&quot;</span> <span class="o">%</span> <span class="n">create_random_string</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Raster</span><span class="p">(</span><span class="n">file_name</span><span class="o">=</span><span class="n">cache_folder</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="n">f_ending</span><span class="p">,</span>
                      <span class="n">raster_array</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">array</span><span class="p">),</span>
                      <span class="n">epsg</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">epsg</span><span class="p">,</span>
                      <span class="n">geo_info</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">geo_transformation</span><span class="p">)</span>
</pre></div>
</div>
<p>In this case, the <code class="docutils literal notranslate"><span class="pre">_make_raster</span></code> method is obsolete. Read more about returning instances of the same class on <a class="reference external" href="https://stackoverflow.com/questions/33533148/how-do-i-specify-that-the-return-type-of-a-method-is-the-same-as-the-class-itsel">stack overflow</a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
When using the `_make_raster` method, add the following magic methods to the `Raster` class (function placeholders are already present in the `raster.py` template):

* `__add__` (`+` operator):
```python
        try:
            self.array += constant_or_raster.array
        except AttributeError:
            self.array += constant_or_raster
        return self._make_raster(&quot;add&quot;)
```

* `__mul__` (`*` operator):
```python
        try:
            self.array = np.multiply(self.array, constant_or_raster.array)
        except AttributeError:
            self.array *= constant_or_raster
        return self._make_raster(&quot;mul&quot;)
```

* `__pow__` (`**` operator):
```python
        try:
            self.array = np.power(self.array, constant_or_raster.array)
        except AttributeError:
            self.array **= constant_or_raster
        return self._make_raster(&quot;pow&quot;)
```

* `__sub__` (`-` operator):
```python
        try:
            self.array -= constant_or_raster.array
        except AttributeError:
            self.array -= constant_or_raster
        return self._make_raster(&quot;sub&quot;)
```

The last item to complete in the `Raster` class is the built-in `save` method that receives a `file_name` (*string*) argument defining the directory and save-as name of the `Raster` instance:

```python
        save_status = geo.create_raster(file_name, self.array, epsg=self.epsg, nan_val=0.0, geo_info=self.geo_transformation)
        return save_status
```
Why do we need the `save_status` variable? First, it states if saving the raster was successful (`save_status=0`), and second, this information could be used to delete the raster from the `__cache__` folder and flush the memory (feel free to do so for speeding up the code).



### Write HSI and cHSI raster creation script
The provided `create_hsi_rasters.py` script already contains required package imports, an `if __name__ == &#39;__main__&#39;` stand-alone statement as well as the void `main`, `get_hsi_curve`, `get_hsi_raster`, and `combine_hsi_rasters` functions:&lt;a name=&quot;chsi-template&quot;&gt;&lt;/a&gt;

```python
# create_hsi_rasters.py
from fun import *
from raster_hsi import HSIRaster, Raster
from time import perf_counter

def combine_hsi_rasters(raster_list, method=&quot;geometric_mean&quot;):
    &quot;&quot;&quot;...
    &quot;&quot;&quot;
    pass


def get_hsi_curve(json_file, life_stage, parameters):
    &quot;&quot;&quot;...
    &quot;&quot;&quot;
    pass


def get_hsi_raster(tif_dir, hsi_curve):
    &quot;&quot;&quot;...
    &quot;&quot;&quot;
    pass


def main():
    pass


if __name__ == &#39;__main__&#39;:
    # define global variables for the main() function
    parameters = [&quot;velocity&quot;, &quot;depth&quot;]
    life_stage = &quot;juvenile&quot;
    fish_file = os.path.abspath(&quot;&quot;) + &quot;\\habitat\\trout.json&quot;
    tifs = {&quot;velocity&quot;: os.path.abspath(&quot;&quot;) + &quot;\\basement\\flow_velocity.tif&quot;,
            &quot;depth&quot;: os.path.abspath(&quot;&quot;) + &quot;\\basement\\water_depth.tif&quot;}
    hsi_output_dir = os.path.abspath(&quot;&quot;) + &quot;\\habitat\\&quot;

    # run code and evaluate performance
    t0 = perf_counter()
    main()
    t1 = perf_counter()
    print(&quot;Time elapsed: &quot; + str(t1 - t0)

```

The `if __name__ == &#39;__main__&#39;` statement contains a time counter (`perf_counter`) that prompts how long running the script takes (typically between 3 to 6 seconds). Make sure that

* the `parameters` list contains `&quot;velocity&quot;` and `&quot;depth&quot;` (as per the `par_dict` in the `config.py` script),
* the file paths are defined correctly, and
* a life stage is defined (i.e., either `&quot;fry&quot;`, `&quot;juvenile&quot;`, `&quot;adult&quot;`, or `&quot;spawning&quot;` as per the */habitat/fish.xlsx*  workbook).

The following paragraphs show step by step how to load the $HSI$ curves from the {ref}`json` file (`get_hsi_curve`), apply them to the `flow_velocity` and `water_depth` rasters (`get_hsi_raster`), and combine the resulting $HSI$ rasters into $cHSI$ rasters (`combine_hsi_rasters`).

The `get_hsi_curve` function will load the $HSI$ curve from the {ref}`json` file (*/habitat/trout.json*) in a dictionary for the two parameters `&quot;velocity&quot;` and `&quot;depth&quot;`. Thus, the goal is to create a `curve_data` dictionary that contains one {ref}`pandas` `DataFrame` object for all parameters (i.e., velocity and depth). For example, `curve_data[&quot;velocity&quot;][&quot;u&quot;]` will be a {ref}`pandas` `Series` of velocity entries (in m/s) that corresponds to `curve_data[&quot;velocity&quot;][&quot;HSI&quot;]`, which is a {ref}`pandas` `Series` of $HSI$ values. Similarly, `curve_data[&quot;depth&quot;][&quot;h&quot;]` is a {ref}`pandas` `Series` of depth entries (in meters) that corresponds to `curve_data[&quot;depth&quot;][&quot;HSI&quot;]`, which is a {ref}`pandas` `Series` of $HSI$ values (corresponds to the curves shown in the [$HSI$ graphs](#hsi-image) above). To extract the desired information from the *JSON* file, `get_hsi_curve` takes three arguments (`json_file`, `life_stage`, and `parameters`) in order to:

* Get the information stored in the *JSON* file with the `read_json` function ([see above](#funs)).
* Instantiate a void `curve_data` {ref}`dict` that will contain the {ref}`pandas` `DataFrame`s for `&quot;velocity&quot;` and `&quot;depth&quot;`.
* Run a loop over the (two) parameters (`&quot;velocity&quot;` and `&quot;depth&quot;`), in which it:
    - Creates a void `par_pairs` {ref}`list` for storing pairs of parameter (`par`) - $HSI$ values as nested lists.
    - Iterates through the length of provided curve data, where valid data pairs (e.g., `[u_value, HSI_value]`) are appended to the `par_pairs` {ref}`list`. This iteration is what actually creates the nested {ref}`list`.
    - Converts the final `par_pairs` list to a {ref}`pandas` `DataFrame` that it adds to the `curve_data` {ref}`dict`.
* `return` the `curve_data` {ref}`dict` with its {ref}`pandas` `DataFrame`s.

```python
# create_hsi_rasters.py
def get_hsi_curve(json_file, life_stage, parameters):
    # read the JSON file with fun.read_json
    file_info = read_json(json_file)
    # instantiate output dictionary
    curve_data = {}
    # iterate through parameter list (e.g., [&quot;velocity&quot;, &quot;depth&quot;])
    for par in parameters:
        # create a void list to store pairs of parameter-HSI values as nested lists
        par_pairs = []
        # iterate through the length of parameter-HSI curves in the JSON file
        for i in range(0, file_info[par][life_stage].__len__():
            # if the parameter is not empty (i.e., __len__ &gt; 0), append the parameter-HSI (e.g., [u_value, HSI_value]) pair as nested list
            if str(file_info[par][life_stage][i][&quot;HSI&quot;]).__len__() &gt; 0:
                try:
                    # only append data pairs if both parameter and HSI are numeric (floats)
                    par_pairs.append([float(file_info[par][life_stage][i][par_dict[par]]),
                                      float(file_info[par][life_stage][i][&quot;HSI&quot;])])
                except ValueError:
                    logging.warning(&quot;Invalid HSI curve entry for {0} in parameter {1}.&quot;.format(life_stage, par)
        # add the nested parameter pair list as pandas DataFrame to the curve_data dictionary
        curve_data.update({par: pd.DataFrame(par_pairs, columns=[par_dict[par], &quot;HSI&quot;])})
    return curve_data
```

In the `main` function, call `get_hsi_curves` to get the $HSI$ curves as a {ref}`dict`. In addition, implement the `cache` and the `log_actions` wrappers  ([recall the descriptions of provided functions](#funs) for the `main` function:

```python
# create_hsi_rasters.py

...

@log_actions
@cache
def main():
    # get HSI curves as pandas DataFrames nested in a dictionary
    hsi_curve = get_hsi_curve(fish_file, life_stage=life_stage, parameters=parameters)

...
```

With the provided `HSIRaster` (`raster_hsi.py`) class, the $HSI$ rasters can be conveniently created in the `get_hsi_raster` function. Before using the `HSIRaster` class, make sure to understand how it works. The `HSIRaster` class inherits from the `Raster` class and initiates its parent class in its `__init__` method through `Raster.__init__(self, file_name=file_name, band=band, raster_array=raster_array, geo_info=geo_info)`. Then, the class calls its `make_hsi` method, which takes an $HSI$ curve (nested {ref}`list`) of two equal {ref}`list` pairs ({ref}`list` of parameters and {ref}`list` of $HSI$ values) as argument. The `make_hsi` method:

* Extracts parameter values (e.g., depth or velocity) from the first element of the nested `hsi_curves` {ref}`list`, and $HSI$ values from the second element of the nested `hsi_curves` {ref}`list`.
* Uses {ref}`numpy`s built-in `np.nditer` function, which iterates through {ref}`numpy` arrays with high computational efficiency (read more about [`nditer`](https://numpy.org/doc/stable/reference/generated/numpy.nditer.html)).
    - The `nditer` loop passes the `par_values` as `x_values` {ref}`list` argument and the `hsi_values` as `y_values` {ref}`list` arguments to the `interpolate_from_list` function ([recall the function descriptions above](#funs)).
    - The array values (i.e., flow velocity or water depth) correspond to the `xi_values` {ref}`list` argument of the `interpolate_from_list` function.
    - The `interpolate_from_list` function then identifies for each element of the `xi_values` {ref}`list` the closest elements (*x_{i}$ values) in the `x_values` {ref}`list` and the corresponding positions in the `y_values` {ref}`list`.
    - The `interpolate_from_list` function passes the identified values to the `interpolate_y` function, which then linearly interpolates the corresponding `yi` value (i.e., an $HSI$ value).
    - Thus, the flow velocity or water depths in `self.array` are row-wise (row-by-row) replaced by $HSI$ values.
* `return`s a `Raster` instance using the pseudo-private `_make_raster` method ([recall its contents](#make-raster)).

```python
# raster_hsi.py
from raster import *

class HSIRaster(Raster):
    def __init__(self, file_name, hsi_curve, band=1, raster_array=None, geo_info=False):
        Raster.__init__(self, file_name=file_name, band=band, raster_array=raster_array, geo_info=geo_info)
        self.make_hsi(hsi_curve)

    def make_hsi(self, hsi_curve):
        par_values = hsi_curve[0]
        hsi_values = hsi_curve[1]
        try:
            with np.nditer(self.array, flags=[&quot;external_loop&quot;], op_flags=[&quot;readwrite&quot;]) as it:
                for x in it:
                    x[...] = interpolate_from_list(par_values, hsi_values, x)
        except AttributeError:
            print(&quot;WARNING: np.array is one-dimensional.&quot;)
        return self._make_raster(&quot;hsi&quot;)
```

Modify the `get_hsi_rasters` function to directly return a `HSIRaster` object:

```python
# create_hsi_rasters.py

...

def get_hsi_raster(tif_dir, hsi_curve):
    return HSIRaster(tif_dir, hsi_curve)
...

```

The `get_hsi_raster` function requires two arguments, which it must receive from the `main` function. For this reason, iterate over the `parameters` {ref}`list` in the `main` function and extract the corresponding raster directories from the `tifs` {ref}`dict` (recall the variable definition in the [standalone statement](#chsi-template)). In addition, save the `Raster` objects returned by the `get_hsi_raster` function in another {ref}`dict` (`eco_rasters`) to combine them in the next step into a $cHSI$ raster.

```python
# create_hsi_rasters.py

...

@log_actions
@cache
def main():
    # get HSI curves as pandas DataFrames nested in a dictionary
    hsi_curve = get_hsi_curve(fish_file, life_stage=life_stage, parameters=parameters)

        # create HSI rasters for all parameters considered and store the Raster objects in a dictionary
    eco_rasters = {}
    for par in parameters:
        hsi_par_curve = [list(hsi_curve[par][par_dict[par]]),
                         list(hsi_curve[par][&quot;HSI&quot;])]
        eco_rasters.update({par: get_hsi_raster(tif_dir=tifs[par], hsi_curve=hsi_par_curve)})
        eco_rasters[par].save(hsi_output_dir + &quot;hsi_%s.tif&quot; % par)
...
```

Of course, one can also loop over the parameters {ref}`list` directly in the `get_hsi_raster` function.

```{admonition} Test if the code works
:class: tip
This is a good moment to test if the code works. Run `create_hsi_rasters.py` and verify that the two *GeoTIFF* files (*habitat/hsi_velocity.tif* and */habitat/hsi_depth.tif*) are created correctly. *QGIS* visualizes the *GeoTIFF*-products and the activated *Identify Features* button in *QGIS* enables to check if the linearly interpolated $HSI$ values agree with the $HSI$ curves in the provided workbook (*/habitat/trout.xlsx*). Thus, load both *GeoTIFF* pairs in *QGIS*: */habitat/hsi_velocity.tif* + */basement/flow_velocity.tif* and */habitat/hsi_depth.tif*  + */basement/water_depth.tif*.
```

Next, we come to the reason why we had to define magic methods for the `Raster` class: combine the $HSI$ rasters using both combination formulae presented above (recall the [product and geometric mean](#combine-methods) formulae), where `&quot;geometric_mean&quot;` should be used by default. The `combine_hsi_rasters` function accepts two arguments (a {ref}`list` of `Raster` objects corresponding to $HSI$ rasters and the `method` to use as *string*).

If the method corresponds to the default value `&quot;geometric_mean&quot;`, then the `power` to be applied to the product of the `Raster` {ref}`list` is calculated from the *n*th root, where *n* corresponds to the number of `Raster` objects in the `raster_list`. Otherwise (e.g., `method=&quot;product&quot;`), the `power` is exactly 1.0.

The `combine_hsi_rasters` function initially creates an empty $cHSI$ `Raster` in the `cache_folder`, with each cell having the value `1.0` (filled through `np.ones`). In a loop over the `Raster` elements of the `raster_list`, the function multiplies each $HSI$ raster with the $cHSI$ raster.

Finally, the function returns the product of all $HSI$ rasters to the power of the previously determined `power` value.


```python
# create_hsi_rasters.py
def combine_hsi_rasters(raster_list, method=&quot;geometric_mean&quot;):
    if method is &quot;geometric_mean&quot;:
        power = 1.0 / float(raster_list.__len__()
    else:
        # supposedly method is &quot;product&quot;
        power = 1.0

    chsi_raster = Raster(cache_folder + &quot;chsi_start.tif&quot;,
                         raster_array=np.ones(raster_list[0].array.shape),
                         epsg=raster_list[0].epsg,
                         geo_info=raster_list[0].geo_transformation)
    for ras in raster_list:
        chsi_raster = chsi_raster * ras

    return chsi_raster ** power
```

To finish the `create_hsi_rasters.py` script, implement the call to the `combine_hsi_rasters` function in the `main` function and save the result as $cHSI$ *GeoTIFF* raster in the `/habitat/` folder:

```python
# create_hsi_rasters.py

...

@log_actions
@cache
def main():
    ...

    for par in parameters:
        hsi_par_curve = [list(hsi_curve[par][par_dict[par]]),
                         list(hsi_curve[par][&quot;HSI&quot;])]
        eco_rasters.update({par: get_hsi_raster(tif_dir=tifs[par], hsi_curve=hsi_par_curve)})
        eco_rasters[par].save(hsi_output_dir + &quot;hsi_%s.tif&quot; % par)

    # get and save chsi raster
    chsi_raster = combine_hsi_rasters(raster_list=list(eco_rasters.values(),
                                      method=&quot;geometric_mean&quot;)
    chsi_raster.save(hsi_output_dir + &quot;chsi.tif&quot;)
...
```

### Run the $HSI$ and $cHSI$ raster creation code

A successful run of the script `create_hsi_rasters.py` should look like this (in *PyCharm*):

![run-chsi](https://github.com/Ecohydraulics/Exercise-geco/raw/master/graphs/run_create_chsi_rasters.png)&lt;br&gt;

Plotted in *QGIS*, the $cHSI$ *GeoTIFF* raster should look like this:

![chsi-results](https://github.com/Ecohydraulics/Exercise-geco/raw/master/graphs/ex-chsi.png)&lt;br&gt;
*The cHSI raster plotted in QGIS, where poor physical habitat quality (cHSI close to 0.0) is colored in red and high physical habitat quality (cHSI close to 1.0) is colored in green.*

### Result interpretation
The presentation of the $cHSI$ raster shows that preferred habitat areas for juvenile trout exist only close to the banks. Also, numerical artifacts of the triangular mesh used by *BASEMENT* are visible. Therefore, the question arises whether the calculated flow velocities and water depths, and in consequence also the $cHSI$ values, close to the banks can be considered representative.

## Calculate the usable habitat area

### Write the code
The $cHSI$ rasters enable the calculation of the available usable habitat area. The previous section featured examples using the fish species *trout* and its *juvenile* life stage, for which we will determine here the usable habitat area $UHA$ (in m$^2$) using a $cHSI$ threshold value (rather than the pixel area weighting approach). So we follow the [threshold formula described above](#uha-methods), using a threshold value of $cHSI_{crit}$ = 0.4. Thus, every pixel that has a $cHSI$ value of 0.4 or greater counts as usable habitat area.

From a technical point of view, this part of the exercise is about converting a raster into a polygon shapefile as well as accessing and modifying the *Attribute Table* of the shapefile.

Similar to the creation of the $cHSI$ raster, there is a template script available for this part of the exercise, called `calculate_habitat_area.py`, which contains package and module imports, an `if __name__ == &#39;__main__&#39;` stand-alone statement, as well as the void `main` and `calculate_habitat_area` functions. The template script looks like this:&lt;a name=&quot;uha-template&quot;&gt;&lt;/a&gt;

```python
# this is calculate_habitat_area.py (template)
from fun import *
from raster import Raster


def calculate_habitat_area(layer, epsg):
    pass


def main():
    pass


if __name__ == &#39;__main__&#39;:
    chsi_raster_name = os.path.abspath(&quot;&quot;) + &quot;\\habitat\\chsi.tif&quot;
    chsi_threshold = 0.4

    main()
```

In the `if __name__ == &#39;__main__&#39;` statement, make sure that the global variable `chsi_raster_name` corresponds to the directory of the $cHSI$ raster created in the previous section. The other global variable (`chsi_threshold`) corresponds to the $cHSI_{crit}$ value of 0.4 that we will use with the [threshold formula](#uha-methods).

In the `main` function, start with loading the $cHSI$ raster (`chsi_raster`) as a [`Raster` object](#raster-class). Then, access the {ref}`numpy` array of the $cHSI$ raster and compare it with `chsi_threshold` using {ref}`numpy`s built-in [*greater_equal*](https://numpy.org/doc/stable/reference/generated/numpy.greater_equal.html) function. `np.greater_equal` takes an array as first argument and a second argument, which is the condition that can be a numeric variable or another {ref}`numpy` array. Then, `np.greater_equal` checks if the elements of the first array are greater than or equal to the second argument. In the case of the second argument being an array, this is an element-wise $\geq$ comparison. The result of `np.greater_equal` is a {ref}`bool` array (`True` where the greater-or-equal condition is fulfilled and `False` otherwise). However, to create an `osgeo.gdal.Dataset` object from the result of `np.greater_equal`, we need a numeric array. For this reason, multiply the result of `np.greater_equal` by 1.0 and assign it as a new {ref}`numpy` array of zeros (`False`) and ones (`True`) to a variable named `habitat_pixels` (see the code block below).

With the `habitat_pixels` array and the georeference of `chsi_raster`, create a new *integer* *GeoTIFF* raster with the *create_raster* function of [flusstools.geotools](https://flusstools.readthedocs.io/en/latest/geotools.html#module-flusstools.geotools.raster_mgmt) (here: `geo.create_raster`). In the following code block the new raster is saved in the */habitat/* folder of the exercise as `habitat-pixels.tif`.

```python
# calculate_habitat_area.py
...

def main():
    # open the chsi raster
    chsi_raster = Raster(chsi_ras_name)
    # extract pixels where the physical habitat quality is higher than the user threshold value
    habitat_pixels = np.greater_equal(chsi_raster.array, chsi_threshold_value) * 1
    # write the habitat pixels to a binary array (0 -&gt; no habitat, 1 -&gt; usable habitat)
    geo.create_raster(os.path.abspath(&quot;&quot;) + &quot;\\habitat\\habitat-pixels.tif&quot;,
                      raster_array=habitat_pixels,
                      epsg=chsi_raster.epsg,
                      geo_info=chsi_raster.geo_transformation)
...
```

In the next step, convert the habitat pixel raster into a polygon shapefile and save it in the */habitat/* folder as `habitat-area.shp`. The conversion of a raster into a polygon shapefile requires that the raster contains only *integer* values, which is the case in the habitat pixel raster (only zeros and ones - [recall the lecture notes](geopy/geo-convert.html#raster2polygon)). With the [*raster2polygon* function of *geo_utils*](https://github.com/hydro-informatics/geo-utils#convert-raster-to-polygon-shapefile), create the new polygon shapefile, specify *habitat-pixels.tif* as `raster_file_name` to be converted, and `/habitat/habitat-area.shp` as output file name.
`geo.raster2polygon` returns an `osgeo.ogr.DataSource` object and we can pass its layer including the information of the *EPSG* authority code (from `chsi_raster`) directly to the not-yet-written `calculate_habitat_area` function:

```python
# calculate_habitat_area.py
...

def main():
    ... (create habitat pixels raster)

    # convert the raster with usable pixels to polygon (must be an integer raster!)
    tar_shp_file_name = os.path.abspath(&quot;&quot;) + &quot;\\habitat\\habitat-area.shp&quot;
    habitat_polygons = geo.raster2polygon(os.path.abspath(&quot;&quot;) + &quot;\\habitat\\habitat-pixels.tif&quot;,
                                          tar_shp_file_name)

    # calculate the habitat area (will be written to the attribute table)
    calculate_habitat_area(habitat_polygons.GetLayer(), chsi_raster.epsg)
...
```

In order for the `calculate_habitat_area` function to produce what its name promises, we need to populate this function as well. For this purpose, use the `epsg` *integer* argument to identify the unit system of the shapefile.


```python
# calculate_habitat_area.py
...

def calculate_habitat_area(layer, epsg):
    # retrieve units
    srs = geo.osr.SpatialReference()
    srs.ImportFromEPSG(epsg)
    area_unit = &quot;square %s&quot; % str(srs.GetLinearUnitsName()
...
```

```{note}
In practice, many mistakes are made due to the incorrect use of area units, which is often not obvious at first because of the size of geospatial data (several gigabytes). There are many units of length and area (meters, feet, acre, hectare, km$^2$) and a difference of an order of magnitude is sometimes only noticed when a critical reviewer or a local expert becomes suspicious. In the application shown here, we use the information of the length units only to output the total area with a correct reference to the area units (m$^2$) on the console, but in practice, this information can save a career.
```

To determine the habitat area, the area of each polygon must be calculated. For this purpose, add a new field to the `layer` in the *Attribute Table*, name it `&quot;area&quot;`, and assign a `geo.ogr.OFTReal` (numeric) data type (recall how to [create a field an data types explained in the lecture notes](geopy/geo-shp.html#add-field)).
Then, create a void {ref}`list` called `poly_size`, in which we will write the area of all polygons that have a field value of `1`. To access the individual polygons (features) of the `layer`, iterate through all features using a `for` loop, which:

* Extracts the polygon of every `feature` using `polygon = feature.GetGeometryRef()`
* Appends the polygon&#39;s area size to the `poly_size` {ref}`list` if the field `&quot;value&quot;` of the `polygon` (at position 0: `feature.GetField(0)`) is 1 (`True`).
* Writes the polygon&#39;s area size to the *Attribute Table*  with `feature.SetField(&quot;area&quot;, polygon.GetArea()`.
* Saves the changes (calculated area) to the shapefile `layer` with `layer.SetFeature(feature)`.

```{attention}
Looping through an attribute table is computationally expensive in *Python*. If a shapefile has many elements (points, lines, polygons), this loop can last for hours, days, or even weeks. Therefore, it can be useful to convert a shapefile into a raster and perform calculations using {ref}`numpy`s computationally efficient built-in functions (C/C++ wrappers), which are many times faster. A particular problem is the processing of large lidar datasets (several million points), where it may be necessary to use other software (read more at [earthdatascience.org](https://www.earthdatascience.org/courses/use-data-open-source-python/data-stories/what-is-lidar-data/explore-lidar-point-clouds-plasio/)).
```

The last information needed after the `for` loop is the total area of the `&quot;value&quot;=1` polygons, which we get by writing the `sum` of the `poly_size` {ref}`list` to the console. Therefore, the second and last part of the `calculate_habitat_area` function looks like this:

```python
# calculate_habitat_area.py
...
def calculate_habitat_area(layer, epsg):

    ... (extract unit system information)

    # add area field
    layer.CreateField(geo.ogr.FieldDefn(&quot;area&quot;, geo.ogr.OFTReal)

    # create list to store polygon sizes
    poly_size = []

    # iterate through geometries (polygon features) of the layer
    for feature in layer:
        # retrieve polygon geometry
        polygon = feature.GetGeometryRef()
        # add polygon size if field &quot;value&quot; is one (determined by chsi_treshold)
        if int(feature.GetField(0):
            poly_size.append(polygon.GetArea()
        # write area to area field
        feature.SetField(&quot;area&quot;, polygon.GetArea()
        # add the feature modifications to the layer
        layer.SetFeature(feature)

    # calculate and print habitat area
    print(&quot;The total habitat area is {0} {1}.&quot;.format(str(sum(poly_size), area_unit)

...
```

```{note}
To calculate other geometry attributes than the polygon area (e.g., envelope extents, derive a convex hull, or get the length of lines), refer to the [functions described in the lecture notes](geopy/geo-shp.html#calc) and use those functions in lieu of `polygon.GetArea()`.
```

### Run the Usable Habitat Area calculation code

A successful run of the script `calculate_habitat_area.py` should look like this (in *PyCharm*):
![run-chsi](https://github.com/Ecohydraulics/Exercise-geco/raw/master/graphs/run_habitat_area.png) &lt;br&gt;

Plotted in *QGIS*, the *habitat-area* shapefile looks like this (use *Categorized* symbology):

![uha-results](https://github.com/Ecohydraulics/Exercise-geco/raw/master/graphs/ex-uha.png) &lt;br&gt;
*The habitat-area shapefile plotted in QGIS with Categorized symbology, where the usable habitat area $UHA$ ($cHSI &gt;$ 0.4) is delineated by the hatched purple patches and their dashed outlines.*

### Result interpretation
The $UHA$ of the analyzed river section represents a very small share of the total wetted area, which can be interpreted as an ecologically poor status of the river. However, a glance at a map and the simulation files of the Flaz example of *BASEMENT* suggests that at a discharge of 50 m$^3$/s, a flood situation can be assumed. As during floods, there are generally higher flow velocities, which are out-of-favor of juvenile fish, the small usable habitat area is finally not surprising.


```{attention}
Remember that the here presented habitat assessment assumes that fish prefer regions with high $cHSI$ values and that rivers with a high proportion of areas with high $cHSI$ values are ecologically particularly valuable. This approach represents an assessment of the physical habitat state with limited information on the functional habitat state.
```

```{admonition} Homework
Rewrite the magic methods of the `Raster` class by using `def __METHOD__(self, other: Raster) -&gt; Raster:` instead of `def __METHOD__(self, constant_or_raster):` and the `_make_raster` method.
```
</pre></div>
</div>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "hydro-informatics/hydro-informatics.github.io",
            ref: "gh-pages",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./exercises"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
        <div class='prev-next-bottom'>
            
    <a class='left-prev' id="prev-link" href="geo-exercises.html" title="previous page">Exercises</a>
    <a class='right-next' id="next-link" href="../numerics/numerical-modeling.html" title="next page">Principles</a>

        </div>
        
        </div>
    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Sebastian Schwindt<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  
  </body>
</html>